package OMP::CGIComponent::MSB;

=head1 NAME

OMP::CGIComponent::MSB - Web display of MSB information

=head1 SYNOPSIS

  use OMP::CGIComponent::MSB;

=head1 DESCRIPTION

Helper methods for generating and displaying portions of web
pages that display MSB comments and general MSB information.

=cut

use 5.006;
use strict;
use warnings;
use Carp;

use Time::Seconds qw(ONE_HOUR);
use CGI qw/ :html *Tr *td /;

use OMP::CGIComponent::Helper;
use OMP::CGIDBHelper;
use OMP::Constants qw(:done);
use OMP::DBServer;
use OMP::Display;
use OMP::Error qw(:try);
use OMP::DateTools;
use OMP::General;
use OMP::Info::Comment;
use OMP::MSBDB;
use OMP::MSBDoneDB;
use OMP::MSBServer;
use OMP::ProjDB;
use OMP::ProjServer;
use OMP::SpServer;
use OMP::UserServer;

use base qw/OMP::CGIComponent/;

$| = 1;

=head1 Routines

=over 4

=item B<fb_msb_active>

Create a table of active MSBs for a given project

  $comp->fb_msb_active($projectid);

=cut

sub fb_msb_active {
  my $self = shift;
  my $projectid = shift;

  # Get project's associated telescope
  my $proj = OMP::ProjServer->projectDetails( $projectid,
                                              "object");

  my $active = OMP::CGIDBHelper::safeProgramDetails( $projectid, 'objects' );

  if (defined $active) {

    # First go through the array quickly to make sure we have
    # some valid entries
    my @remaining = grep { $_->remaining > 0 } @$active;
    my $total = @$active;
    my $left = @remaining;
    my $done = $total - $left;
    if ($left == 0) {
      if ($total == 1) {
        print "The MSB present in the science program has been observed.<br>\n";
      } else {
        print "All $total MSBs in the science program have been observed.<br>\n";
      }

    } else {

      # Nice little message letting us know no of msbs present in the table
      # that have not been observed.
      if ($done > 0) {
        if ($done == 1) {
          print "$done out of $total MSBs present in the science program has been observed.<br>\n";
        } else {
          print "$done out of $total MSBs present in the science program have been observed.<br>\n";
        }
      }

      # Now print the table (with an est. time column) if we have content
      $self->msb_table(msbs=>$active, est_column=>1, opacity_column=>1, telescope=>$proj->telescope,);

    }
  }
}

=item B<fb_msb_observed>

Create a table of observed MSBs for a given project

  $comp->fb_msb_observed($projectid);

=cut

sub fb_msb_observed {
  my $self = shift;
  my $projectid = shift;

  # Get observed MSBs
  my $observed = OMP::MSBServer->observedMSBs({projectid => $projectid,
                                               format => 'data',
                                               include_undo => 1});

  # Get project's associated telescope
  my $proj = OMP::ProjServer->projectDetails( $projectid,
                                              "object");

  # Generate the HTML table
  (@$observed) and $self->msb_table(msbs=>$observed, telescope=> $proj->telescope);
}

my ( $NBSP ) = ( '&nbsp;' );

=item B<msb_action>

Working in conjunction with the B<msb_comments> function described elsewhere
in this document this function decides if the form generated by B<msb_comments>
was submitted, and if so, what action to take.

  $comp->msb_action();

Takes a C<CGI> query object as the only argument.

=cut

sub msb_action {
  my $self = shift;

  my $q = $self->cgi;

  if ($q->param("submit_msb_comment")) {
    # Submit a comment
    try {
      # Create the comment object
      my $trans = $q->param( 'transaction' );
      my $comment = new OMP::Info::Comment( author => $self->auth->user,
                                            text => $q->param('comment'),
                                            status => OMP__DONE_COMMENT,
                                            ( $trans ? ( 'tid' => $trans )
                                              : ()
                                            )
                                          );

      # Add the comment
      OMP::MSBServer->addMSBcomment( $q->param('projectid'),
                                     $q->param('msbid'),
                                     $comment );
      print $q->h2("MSB comment successfully submitted");
    } catch OMP::Error::MSBMissing with {
      my $Error = shift;
      print "MSB not found in database:<p>$Error";
    } otherwise {
      my $Error = shift;
      print "An error occurred preventing the comment submission:<p>$Error";
    };

  } elsif ($q->param("Remove")) {
    # Mark msb as 'all done'
    try {
      OMP::MSBServer->alldoneMSB( $q->param('projectid'), $q->param('checksum') );
      print $q->h2("MSB removed from consideration");
    } catch OMP::Error::MSBMissing with {
      my $Error = shift;
      print "MSB not found in database:<p>$Error";
    } otherwise {
      my $Error = shift;
      print "An error occurred while attempting to mark the MSB as Done:<p>$Error";
    };

  } elsif ($q->param("Undo")) {
    # Unmark msb as 'done'.
    try {
      OMP::MSBServer->undoMSB(
          $q->param('projectid'), $q->param('checksum'), $q->param('transaction'));
      print $q->h2("MSB done mark removed");
    } catch OMP::Error::MSBMissing with {
      my $Error = shift;
      print "MSB not found in database:<p>$Error";
    } otherwise {
      my $Error = shift;
      print "An error occurred while attempting to remove the MSB Done mark:<p>$Error";
    };

  } elsif ($q->param("unRemove")) {
    # Unremove a removed MSB.
    try {
      OMP::MSBServer->unremoveMSB( $q->param('projectid'), $q->param('checksum') );
      print $q->h2("MSB no longer removed from consideration");
    } catch OMP::Error::MSBMissing with {
      my $Error = shift;
      print "MSB not found in database:<p>$Error";
    } otherwise {
      my $Error = shift;
      print "An error occurred while attempting to remove the MSB Done mark:<p>$Error";
    };
  }
}

=item B<msb_comments>

Creates an HTML table of MSB comments.

  $comp->msb_comments($msbcomments, $sp);

Takes a reference to an array of C<OMP::Info::MSB> objects as the second argument.
Last argument is an optional Sp object.

=cut

sub msb_comments {
  my $self = shift;
  my $commentref = shift;
  my $sp = shift;

  my $q_original = $self->cgi;

  my @output;
  if ($q_original->param('show') =~ /observed/) {
    @output = grep {$_->comments->[0]->status != OMP__DONE_FETCH} @$commentref;
  } elsif ($q_original->param('show') =~ /current/) {
    @output = grep {$sp->existsMSB($_->checksum)} @$commentref if defined $sp;
  } else {
    @output = @$commentref;
  }

  print <<'TABLE';
<table class="infobox" width="100%" cellspacing="0"
  border="0"
  cellpadding="3"
  >
TABLE

  # Colors associated with statuses
  my %colors = (&OMP__DONE_FETCH => '#c9d5ea',
                &OMP__DONE_DONE => '#c6bee0',
                &OMP__DONE_REMOVED => '#8075a5',
                &OMP__DONE_COMMENT => '#9f93c9',
                &OMP__DONE_UNDONE => '#ffd8a3',
                &OMP__DONE_ABORTED => '#9573a0',
                &OMP__DONE_REJECTED => '#bc5a74',
                &OMP__DONE_SUSPENDED => '#ffb959',
                &OMP__DONE_UNREMOVED => '#8075a5',
  );

  my ( $table_cols, $header_rows, $i ) = ( 4, 2, 1 );

  # For CGI+form.
  my %common_hidden = (
    'show_output' => 1,
  );

  foreach my $field (qw/utdate telescope/) {
    my $value = $q_original->param($field);
    $common_hidden{$field} = $value if length $value;
  }

  # Create new CGI object.  This object is empty (no parameters) so that
  # when we generate per-transaction and per-MSB forms, they use the given
  # default parameters rather than those in the original CGI object.
  # (Otherwise after submitting a form, e.g. to undo an MSB, all forms will
  # contain that MSB's checksum and transaction identifier!)
  my $q = new CGI({});

  foreach my $msb (@output) {

    # If the MSB exists in the science program we'll provide a "Remove" button
    # and we'll be able to display the number of remaining observations.
    my $exists = $sp && $sp->existsMSB($msb->checksum) ;

    # this will be the actual science program MSB if it exists
    # We need this so that we can provide the correct button types
    my $spmsb;

    my $remstatus = '';
    if ($exists) {
      $spmsb = $sp->fetchMSB( $msb->checksum );
      my $remaining = $spmsb->remaining;
      if ($spmsb->isRemoved) {
        $remstatus = "REMOVED";
      } elsif ($remaining == 0) {
        $remstatus = "COMPLETE";
      } else {
        $remstatus = "Remaining: $remaining";
      }
    }

    # Get the MSB title
    my $msbtitle = $msb->title;
    (!$msbtitle) and $msbtitle = "[NONE]";

    # Group the comments by transaction ID, while otherwise
    # preserving the ordering (although it's not clear if this
    # is well established).
    my @comments;
    do {
        my %groups = ();
        foreach my $c ($msb->comments()) {
            my $cur = $c->tid;

            unless ($cur) {
              # Consider each comment with empty|undef transaction id unique.
              push @comments, [$c];
            }
            elsif (exists $groups{$cur}) {
                # Add comment to existing group.
                push @{$groups{$cur}}, $c;
            }
            else {
                # Create a new group.
                push @comments, ($groups{$cur} = [$c]);
            }
        }
    };

    my $comments = scalar @comments;

    $self->_print_msb_header(
      'count' => $i,
      # (2 * $comments -1): number of comments & dividers between two comments.
      'count-rowspan' => $header_rows + ( $comments ? 2 * $comments - 1 : 0 ),
      'title' => $msbtitle,
      # Count goes in the 1st column.
      'title-colspan' => $table_cols - 1,
      'status' => $remstatus,
      'target' => $msb->target,
      'inst' => $msb->instrument,
      'waveband' => $msb->waveband,
    );
    $i++;

    $common_hidden{'projectid'} = $msb->projectid;
    $common_hidden{'checksum'} = $msb->checksum;

    $self->_print_transaction_comments(
      { 'comments' => \@comments,
        'comment-colspan' => $table_cols - 2,
        'colors' => \%colors,
        'hidden' =>
          [ OMP::Display->make_hidden_fields(
              $q, \%common_hidden,
            )
          ],
        'exists' => $exists,
      }
    ) ;

    # Make "Remove" and "undo" buttons if the MSB exists in the
    # science program
    if ( $exists ) {
      my ($remove_button, $remove_note);
      unless ($spmsb->isRemoved) {
        $remove_button = 'Remove';
        $remove_note = '(disable this MSB in the science program)';
      } else {
        $remove_button = 'unRemove';
        $remove_note = '(re-enable this MSB in the science program)';
      }

      print
        Tr( td( $NBSP ),
            td( { 'colspan' => , $table_cols - 1 },
              start_form_absolute($q),
              $q->submit($remove_button), $remove_note,
              OMP::Display->make_hidden_fields( $q, { %common_hidden } ),
              $q->endform
            )
          ) ;
    }

    print
      Tr( { 'bgcolor' => "#d3d3dd" },
          qq[<td colspan="$table_cols"> $NBSP</td>]
        );
  }
  print "</table>";
}

=item B<msb_comments_by_project>

Show MSB comments sorted by project

  $comp->msb_comments_by_project(\@msbcomments);

Takes a reference to a data structure containing MSBs and their comments sorted by project.

=cut

sub msb_comments_by_project {
  my $self = shift;
  my $comments = shift;

  my $q = $self->cgi;
  my %sorted;

  # Get the cgi-bin URL
  my $url = OMP::Config->getData( 'cgidir' );

  foreach my $msb (@$comments) {
    my $projectid = $msb->projectid;
    $sorted{$projectid} = [] unless exists $sorted{$projectid};
    push(@{ $sorted{$projectid} }, $msb);
  }

  foreach my $projectid (sort keys %sorted) {
    print $q->h2("Project: <a href='$url/projecthome.pl?project=$projectid'>$projectid</a>");
    my $sp = OMP::MSBServer->getSciProgInfo($projectid);
    $self->msb_comments(\@{$sorted{$projectid}}, $sp);
    print $q->hr;
  }
}

=item B<msb_comment_form>

Create a form for submitting an MSB comment.  If any of the values the form
takes are available in the query param list they can be used as defaults.

  $comp->msb_comment_form(1);

If the argument is true any available params are used as defaults.

=cut

sub msb_comment_form {
  my $self = shift;
  my $defaults = shift;

  my $q = $self->cgi;

  my %defaults;
  if ($defaults) {
    # Use query param values as defaults
    %defaults = map {$_, $q->param($_)} qw/comment msbid/;
  } else {
    %defaults = (comment => undef,
                 msbid =>$q->param('checksum'),)
  }

  print start_form_absolute($q);
  print "<table border=0><tr><td valign=top>User ID: </td><td>";
  print $self->auth->user->userid;
  print "</td><tr><td valign=top>Comment: </td><td>";

  print
    OMP::Display->make_hidden_fields(
      $q,
      { 'show_output' => 1,
        'submit_msb_comment' => 1,
        # This is checksum not transaction id.
        'msbid' => $defaults{'msbid'},
        'transaction' => $q->param( 'transaction' )
      }
    ),
    _make_non_empty_hidden_fields( $q, qw[ projectid utdate telescope ]) ;

  print $q->textarea(-name=>'comment',
                     -rows=>5,
                     -columns=>80,
                     -default=>$defaults{comment},);
  print "</td><tr><td colspan=2 align=right>";
  print $q->submit("Submit");
  print "</td></table>";
  print $q->endform;
}

=item B<msb_sum>

Displays the project details (lists all MSBs)

  $comp->msb_sum($projectid);

=cut

sub msb_sum {
  my $self = shift;
  my $projectid = shift;

  my $q = $self->cgi;

  print $q->h2("MSB summary");
  my $msbsum = OMP::CGIDBHelper::safeProgramDetails( $projectid,
                                                     'htmlcgi' );
  print $msbsum if defined $msbsum;

}

=item B<msb_sum_hidden>

Creates text showing current number of msbs, but not actually display the
program details.

  $comp->msb_sum_hidden($projectid);

=cut

sub msb_sum_hidden {
  my $self = shift;
  my $projectid = shift;

  my $q = $self->cgi;;

  my $sp;
  my @msbs;
  try {
    my $db = OMP::MSBDB->new(DB=>new OMP::DBbackend,
                             ProjectID => $projectid );

    # Our XML query for retrieving all MSBs
    my $xml = "<MSBQuery>"
      ."<projectid full=\"1\">$projectid</projectid>"
        ."<disableconstraint>all</disableconstraint>"
          ."</MSBQuery>";

    my $query = new OMP::MSBQuery( XML => $xml );

    # Run the query
    @msbs = $db->queryMSB($query);

  } catch OMP::Error::UnknownProject with {
    print "Science program for $projectid not present in database";
  } otherwise {
    my $E = shift;
    print "Error obtaining science program details for project $projectid [$E]";
  };


  print $q->h2("Current MSB status");
  if (scalar(@msbs) == 1) {
    print "1 MSB currently stored in the database.";
    print " Click <a href='fbmsb.pl?project=$projectid'>here</a> to list its contents.";
  } else {
    print scalar(@msbs) . " MSBs currently stored in the database.";
    print " Click <a href='fbmsb.pl?project=$projectid'>here</a> to list them all."
      unless (! @msbs);
  }
  print $q->hr;

}

=item B<msb_table>

Create a table containing information about given MSBs

  $comp->msb_table(
            msbs=>$msbs,
            est_column=>$show_estimated,
            telescope=>$telescope,);


Arguments should be provided in hash form, with the following
keys:

  msbs       - An array reference containing C<OMP::Info::MSB> objects (required).
  est_column - True if an "Est. time" column, for presenting the estimated
               time in seconds, should be presented.
  opacity_column - True if opacity range column should be presented.
  telescope  - A telescope name.

=cut

sub msb_table {
  my $self = shift;
  my %args = @_;

  # Check for required arguments
  for my $key (qw/msbs telescope/) {
    throw OMP::Error::BadArgs("The argument [$key] is required.")
      unless (defined $args{$key});
  }

  my $q = $self->cgi;
  my $program = $args{msbs};
  my $est_column = $args{est_column};
  my $opacity_column = $args{'opacity_column'};
  my $telescope = $args{telescope};

  # Decide whether to show MSB targets or MSB name
  my $display_msb_name = OMP::Config->getData( 'msbtabdisplayname',
                                               telescope => $telescope,);
  my $alt_msb_column = ($display_msb_name ? 'Name' : 'Target');

  print "<table width=100%>";
  print "<tr bgcolor=#bcbee3><td><b>MSB</b></td>";
  print "<td><b>$alt_msb_column</b></td>";
  print "<td><b>Waveband</b></td>";
  print "<td><b>Instrument</b></td>";

  # Show the estimated time column  if it's been asked for
  print "<td><b>Est. time</b></td>"
    unless (! $est_column);

  print '<td><b>Opacity range</b></td>' if $opacity_column;

  # Only bother with a remaining column if we have remaining
  # information
  print "<td><b>Remaining</b></td>"
    if (defined $program->[0]->remaining);

  # And let's have an N Repeats column if that's available
  print "<td><b>N Repeats</b></td>"
    if (defined $program->[0]->nrepeats);

  # Note that this doesnt really work as code shared for MSB and
  # MSB Done summaries
  my $i;
  foreach my $msb (@$program) {
    # skip if we have a remaining field and it is 0 or less
    # dont skip if the remaining field is simply undefined
    # since that may be a valid case
    next if defined $msb->remaining && $msb->remaining <= 0;

    # Skip if this is only a fetch comment
    next if (scalar @{$msb->comments} &&
             $msb->comments->[0]->status == &OMP__DONE_FETCH);

    # Create a summary table
    $i++;
    print "<tr><td>$i</td>";

    print "<td>" . ($display_msb_name ? $msb->title : $msb->target) . "</td>";
    print "<td>" . $msb->waveband . "</td>";
    print "<td>" . $msb->instrument . "</td>";

    if ($est_column) {
      if ($msb->timeest) {
        # Convert estimated time from seconds to hours
        my $timeest = sprintf "%.2f hours", ($msb->timeest / ONE_HOUR);
        print "<td>$timeest</td>";
      } else {
        print "<td>--</td>";
      }
    }

    if ($opacity_column) {
      my $opacity_range = $msb->tau();
      if ($opacity_range) {
        print '<td>' . $opacity_range . '</td>';
      }
      else {
        print "<td>--</td>";
      }
    }

    print "<td>" . $msb->remaining . "</td>"
      unless (! defined $msb->remaining);
    print "<td>" . $msb->nrepeats . "</td>"
      unless (! defined $msb->nrepeats);
  }

  print "</table>\n";
}

=item B<observed_form>

Create a form with a textfield for inputting a UT date and submitting it.

  $comp->observed_form();

=cut

sub observed_form {
  my $self = shift;

  my $q = $self->cgi;

  # Match case of telescope type value as present in database so that it would
  # be already selected in selection list.
  my %tel = OMP::General->find_in_post_or_get( $q, 'telescope' );
  for ( $tel{'telescope'} ) {

    defined $_ and $q->param( 'telescope', uc $_ );
  }


  my $db = new OMP::ProjDB( DB => OMP::DBServer->dbConnection, );

  # Get today's date and use that ase the default
  my $utdate = OMP::DateTools->today;

  # Get the telescopes for our popup menu
  my @tel = $db->listTelescopes;
  my %tel_labels = map {$_, $_} @tel;
  unshift @tel, 0;
  $tel_labels{0} = "Please select";

  print "<table><td align='right'><b>";
  print start_form_absolute($q);
  print $q->hidden(-name=>'show_output',
                   -default=>1,);
  print "UT Date: </b><td>";
  print $q->textfield(-name=>'utdate',
                      -size=>15,
                      -maxlength=>75,
                      -default=>$utdate,);
  print "</td><td></td><tr><td align='right'><b>Telescope: </b></td><td>";
  print $q->popup_menu(-name=>'telescope',
                       -values=>\@tel,
                       -labels=>\%tel_labels,
                       -default=>0,);
  print "</td><td colspan=2>";
  print $q->submit("View Comments");
  print $q->endform;
  print "</td></table>";

}

=pod

=item B<_print_msb_header>

Given a hash with information about MSB, print MSB header as (HTML)
table rows and columns.

  $comp->_print_msb_header(
    'title' => <MSB title>,
    'title-colspan' => <column-span for the title>,
    'count' => <current number of the MSB>,
    'count-rowspan' => <row-span for current number of the MSB>,
    'status' => <MSB status>,
    'inst' => <instrument>
    'target' => <target>,
    'waveband' => <frequency in Hz>,
  );

MSB count and title are printed in one row; status, target, waveband,
and instrument in the second.  The MSB count table cell spans the rows
as long as title rows plus the number of comments with distinct
transaction ids.

=cut

sub _print_msb_header {
  my $self = shift;
  my ( %info ) = @_;

  return unless %info;

  my $text_pos = { 'valign' => 'top', 'align' => 'left' };
  print
    Tr( $text_pos,
        th( { 'align' => 'right',
              'rowspan' => $info{'count-rowspan'} || 1
            },
            $info{'count'} . '.'
          ),
        th( { 'colspan' => $info{'title-colspan'} },
            $info{'title'} || $NBSP ,
          ),
      ),
    Tr( $text_pos,
        td( { 'align' => 'center',
              'rowspan' => $info{'count-rowspan'} - 1
            },
            $info{'status'} || $NBSP
          ),
        td( { 'colspan' =>  $info{'title-colspan'} - 1 },
            join +( $NBSP ) x 2,
              map
                { my $label = $_->[0];
                  join $NBSP, ( $label ? b( $label . ':' ) : '' ), $_->[1];
                }
                [ 'Target'     , $info{'target'} ],
                [ 'Waveband'   , OMP::General::frequency_in_xhz( $info{'waveband'} ) ],
                [ 'Instrument' , $info{'inst'} ]
          )
      ) ;

  return;
}

=pod

=item B<_print_transaction_comments>

Given array reference of groups of OMP::Info::Comment objects associated with a
transaction id, print the comments in <p>, with dividers (<hr>) if
appropriate.

  $comp->_print_transaction_comments(
    { 'comments' => <array ref of arrays of OMP::Info::Comment objects>,
      'comment-colspan' => <column-span for comment table cells>,
      'colors' =>
        <hash ref of keys as OMP__DONE* status, colors as values>',
      'hidden' =>
        <array ref of hidden field HTML code strings
          to pass to "Add comment to MSB" form>,
      'exists' => <whether or not the MSB still exists>,
    }
  );

See also L<OMP::Constants/MSB Done constants>.

=cut

sub _print_transaction_comments {

  my ( $self, $args ) = @_;
  my $query = $self->cgi;

  return
    unless $query
    && $args && OMP::General->hashref_keys_size( $args )
    ;

  my %prop = ( 'valign' => 'top', 'align' => 'left' );

  my $i_group = 0;
  foreach my $comment_group (@{$args->{'comments'}}) {
    if ($i_group) {
      # Divider (Blank row) between comments with different transaction ids.
      print Tr(
        td({'align' => 'center', 'valign' => 'middle', 'colspan' => 2},
           hr
        ));
    }

    my @buttons = $query->submit('Add Comment');
    if ($args->{'exists'}) {
      # Check whether the transaction has a "done" but no "undone".
      my $n_done = 0;
      foreach my $c (@$comment_group) {
        $n_done ++ if $c->status == OMP__DONE_DONE;
        $n_done -- if $c->status == OMP__DONE_UNDONE;
      }
      push @buttons, $query->submit('Undo') if $n_done > 0;
    }

    my $i_comment = 0;
    foreach my $c (@$comment_group) {
      my $cur = $c->tid;
      my $color = $args->{'colors'}->{$c->status};

      if ($i_comment) {
        # Divider between two comments with the same transaction ids.
        print hr;
      }
      else {
        # Start of comments.
        my @comment_form = (defined $cur)
          ? ( start_form_absolute($query), "\n",
              @buttons, "\n",
              @{ $args->{'hidden' } }, "\n",
              $query->hidden(-name => 'transaction', -default => $cur),
              $query->endform, "\n", )
          : ( '&nbsp;' );

        print
          start_Tr({%prop, bgcolor => $color}),
          td(@comment_form),
          start_td( { 'colspan' => $args->{'comment-colspan'} } ) ;
      }

      # The actual comment.  Finally!
      my $author = $c->author;
      print div(
        {'class' => 'black', 'style' => sprintf('background-color: %s;', $color)},
        join(', ',
            i($c->date . ' UT'),
            $author ? $author->html : ()
            #, $cur ? '( ' . $cur . ' )' : '--'
        ),
        '<br>', $c->text);

      $i_comment ++;
    }

    print end_td, end_Tr;

    $i_group ++;
  }
}

=pod

=item B<_make_non_empty_hidden_fields>

Given C<CGI> object and the parameter names associated with the
object, returns an array of HTML strings of hidden fields for those
parameters which have non empty values.

  print
    _make_non_empty_hidden_fields( $cgi, qw[ telescope utdate ] );

=cut

sub _make_non_empty_hidden_fields {

  my ( $cgi, @fields ) = @_;

  return
    OMP::Display->make_hidden_fields(
      $cgi,
      { map
          { length $cgi->param( $_ ) ? ( $_ => $cgi->param( $_ ) )
              : ()
          }
          @fields
      }
    ) ;
}

=back

=head1 SEE ALSO

C<OMP::CGI::MSBPage>

=head1 AUTHOR

Kynan Delorey E<lt>k.delorey@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2004 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the
Free Software Foundation, Inc., 59 Temple Place, Suite 330,
Boston, MA  02111-1307  USA

=cut

1;
